from sdl2.rect import SDL_Rect
from dataclasses import dataclass
import math

from compygui.datatypes.vector2 import Vector2, IVector2


@dataclass
class Rect2:
    """A 2D rectangle.

    x: Position on the X axis.
    y: Position on the Y axis.
    w: Size on the X axis (width).
    h: Size on the Y axis (height).
    """

    def __init__(self, x: float, y: float, w: float, h: float) -> None:
        super().__init__()
        self.x: float = x
        self.y: float = y
        self.w: float = w
        self.h: float = h

    @staticmethod
    def from_vectors(topleft: Vector2 | IVector2, size: Vector2 | IVector2) -> Rect2:
        """Creates a Rect2() from two Vector2()s/IVector2()s

        topleft: The Vector2()/IVector2() that provides the X and Y components
        size: The Vector2()/IVector2() that provides the W and H components
        """
        return Rect2(topleft.x, topleft.y, size.x, size.y)

    @staticmethod
    def ZERO() -> Rect2:
        """Equivalent to Rect2(0, 0, 0, 0)"""
        return Rect2(0, 0, 0, 0)

    @staticmethod
    def ONE() -> Rect2:
        """Equivalent to Rect2(0, 0, 0, 0)"""
        return Rect2(0, 0, 0, 0)

    def center(self) -> Vector2:
        """Returns the position of the center of the Rect2() as a Vector2()"""
        return Vector2(self.x + (self.w / 2.0), self.y + (self.h / 2.0))

    def topleft(self) -> Vector2:
        """Equivalent to Vector2(self.x, self.y)"""
        return Vector2(self.x, self.y)

    def size(self) -> Vector2:
        """Equivalent to Vector2(self.w, self.h)"""
        return Vector2(self.w, self.h)

    def rounded(self) -> IRect2:
        """Returns an IRect2() generated by rounding this Rect2()"""
        return IRect2(
            int(round(self.x)),
            int(round(self.y)),
            int(round(self.w)),
            int(round(self.h)),
        )

    def ceiled(self) -> IRect2:
        """Returns an IRect2() generated by ceiling (rounding up) this Rect2()"""
        return IRect2(
            int(math.ceil(self.x)),
            int(math.ceil(self.y)),
            int(math.ceil(self.w)),
            int(math.ceil(self.h)),
        )

    def floored(self) -> IRect2:
        """Returns an IRect2() generated by ceiling (rounding down) this Rect2()"""
        return IRect2(
            int(math.floor(self.x)),
            int(math.floor(self.y)),
            int(math.floor(self.w)),
            int(math.floor(self.h)),
        )


@dataclass
class IRect2:
    """An integer 2D rectangle."""

    def __init__(self, x: int, y: int, w: int, h: int) -> None:
        super().__init__()
        self.x: int = x
        self.y: int = y
        self.w: int = w
        self.h: int = h

    @staticmethod
    def from_vectors(topleft: IVector2, size: IVector2) -> IRect2:
        """Creates an IRect2() from two IVector2()s

        topleft: The IVector2() that provides the X and Y components
        size: The IVector2() that provides the W and H components
        """
        return IRect2(topleft.x, topleft.y, size.x, size.y)

    @staticmethod
    def ZERO() -> IRect2:
        """Equivalent to IRect2(0, 0, 0, 0)"""
        return IRect2(0, 0, 0, 0)

    @staticmethod
    def ONE() -> IRect2:
        """Equivalent to IRect2(1, 1, 1, 1)"""
        return IRect2(1, 1, 1, 1)

    def center(self) -> IVector2:
        """Returns the position of the center of the IRect2() as a IVector2()"""
        return IVector2(self.x + (self.w // 2), self.y + (self.h // 2))

    def topleft(self) -> IVector2:
        """Equivalent to IVector2(self.x, self.y)"""
        return IVector2(self.x, self.y)

    def size(self) -> IVector2:
        """Equivalent to IVector2(self.w, self.h)"""
        return IVector2(self.w, self.h)

    def floaty(self) -> Rect2:
        """Returns an IRect2() generated by rounding this Rect2()"""
        return Rect2(self.x, self.y, self.w, self.h)

    def as_sdl_rect(self) -> SDL_Rect:
        """Returns an SDL_Rect structure with the values of this IRect2()"""
        return SDL_Rect(x=self.x, y=self.y, w=self.w, h=self.h)


@dataclass
class RGBAMask:
    """Represents an RGBA color mask/format"""

    def __init__(self, *args, r: int, g: int, b: int, a: int) -> None:
        self.r: int = r
        self.g: int = g
        self.b: int = b
        self.a: int = a

    @staticmethod
    def RGBA() -> RGBAMask:
        """Equivalent to RGBAMask(r=0xFF000000, g=0x00FF0000, b=0x0000FF00, a=0x000000FF)"""
        return RGBAMask(r=0xFF000000, g=0x00FF0000, b=0x0000FF00, a=0x000000FF)

    @staticmethod
    def ARGB() -> RGBAMask:
        """Equivalent to RGBAMask(a=0xFF000000, r=0x00FF0000, g=0x0000FF00, b=0x000000FF)"""
        return RGBAMask(a=0xFF000000, r=0x00FF0000, g=0x0000FF00, b=0x000000FF)

    @staticmethod
    def ABGR() -> RGBAMask:
        """Equivalent to RGBAMask(a=0xFF000000, b=0x00FF0000, g=0x0000FF00, r=0x000000FF)"""
        return RGBAMask(a=0xFF000000, b=0x00FF0000, g=0x0000FF00, r=0x000000FF)

    @staticmethod
    def ZERO() -> RGBAMask:
        """Equivalent to RGBAColor(r=0, g=0, b=0, a=0)"""
        return RGBAMask(r=0, g=0, b=0, a=0)

    def as_int(self) -> int:
        return self.r | self.g | self.b | self.a


@dataclass
class RGBAColor:
    """Represents an RGBA color with variable bit depth
    (when using RGBAColor().as_bytes())
    """

    def __init__(self, *args, r: int, g: int, b: int, a: int) -> None:
        self.r: int = r
        self.g: int = g
        self.b: int = b
        self.a: int = a

    @staticmethod
    def WHITE() -> RGBAColor:
        """Equivalent to RGBAColor(r=255, g=255, b=255, a=255)"""
        return RGBAColor(r=255, g=255, b=255, a=255)

    @staticmethod
    def BLACK() -> RGBAColor:
        """Equivalent to RGBAColor(r=0, g=0, b=0, a=255)"""
        return RGBAColor(r=0, g=0, b=0, a=255)

    @staticmethod
    def TWHITE() -> RGBAColor:
        """Equivalent to RGBAColor(r=255, g=255, b=255, a=0)"""
        return RGBAColor(r=255, g=255, b=255, a=0)

    @staticmethod
    def TBLACK() -> RGBAColor:
        """Equivalent to RGBAColor(r=0, g=0, b=0, a=0)

        Same as RGBAColor.ZERO()
        """
        return RGBAColor(r=0, g=0, b=0, a=0)

    @staticmethod
    def ZERO() -> RGBAColor:
        """Equivalent to RGBAColor(r=0, g=0, b=0, a=0)

        Same as RGBAColor.TBLACK()
        """
        return RGBAColor(r=0, g=0, b=0, a=0)

    # TODO: Add more colors

    def as_int(self, bits_per_channel: int) -> int:
        if bits_per_channel > 8:
            raise ValueError("bits_per_channel must be in range(0, 8) (0-7)")

        return (
            self.a
            | self.b << (bits_per_channel * 1)
            | self.g << (bits_per_channel * 2)
            | self.r << (bits_per_channel * 3)
        )
