"""
ComPyGUI - A competent Python GUI library
  Copyright (C) 2026  FluffyKn1ght

Please see the NOTICE file or compygui.compygui.ComPyGuiApp.NOTICE
for important license information.
https://github.com/FluffyKn1ght/compygui
"""

import math

from dataclasses import dataclass
from typing import Any

from sdl2.rect import SDL_Rect


@dataclass
class IVector2:
    """An integer 2D vector."""

    def __init__(self, x: int, y: int) -> None:
        super().__init__()
        self.x: int = x
        self.y: int = y

    def __or__(self, value: Any) -> IVector2:
        if type(value) is IVector2:
            return IVector2(
                self.x if self.x != 0 else value.x, self.y if self.y != 0 else value.y
            )
        else:
            raise ValueError(
                f"Can't {'"|"'} an IVector2 and {type(value).__name__} together "
            )

    def floaty(self) -> Vector2:
        """Returns a Vector2() generated with the values of this IVector2()"""
        return Vector2(self.x, self.y)

    @staticmethod
    def ZERO() -> IVector2:
        """Equivalent to IVector2(0, 0)."""
        return IVector2(0, 0)

    @staticmethod
    def ONE() -> IVector2:
        """Equivalent to IVector2(1, 1)."""
        return IVector2(1, 1)

    @staticmethod
    def UP() -> IVector2:
        """Equivalent to IVector2(0, -1)."""
        return IVector2(0, -1)

    @staticmethod
    def DOWN() -> IVector2:
        """Equivalent to IVector2(0, 1)."""
        return IVector2(0, 1)

    @staticmethod
    def LEFT() -> IVector2:
        """Equivalent to IVector2(-1, 0)."""
        return IVector2(-1, 0)

    @staticmethod
    def RIGHT() -> IVector2:
        """Equivalent to IVector2(1, 0)."""
        return IVector2(1, 0)


@dataclass
class Vector2:
    """A 2D vector.

    x: The X axis.
    y: The Y axis.
    """

    def __init__(self, x: float, y: float) -> None:
        super().__init__()
        self.x: float = x
        self.y: float = y

    def __or__(self, value: Any) -> Vector2:
        if type(value) is Vector2:
            return Vector2(
                self.x if self.x != 0 else value.x, self.y if self.y != 0 else value.y
            )
        else:
            raise ValueError(
                f"Can't {'"|"'} a Vector2 and {type(value).__name__} together "
            )

    @staticmethod
    def ZERO() -> Vector2:
        """Equivalent to Vector2(0, 0)."""
        return Vector2(0, 0)

    @staticmethod
    def ONE() -> Vector2:
        """Equivalent to Vector2(1, 1)."""
        return Vector2(1, 1)

    @staticmethod
    def UP() -> Vector2:
        """Equivalent to Vector2(0, -1)."""
        return Vector2(0, -1)

    @staticmethod
    def DOWN() -> Vector2:
        """Equivalent to Vector2(0, 1)."""
        return Vector2(0, 1)

    @staticmethod
    def LEFT() -> Vector2:
        """Equivalent to Vector2(-1, 0)."""
        return Vector2(-1, 0)

    @staticmethod
    def RIGHT() -> Vector2:
        """Equivalent to Vector2(1, 0)."""
        return Vector2(1, 0)

    def rounded(self) -> IVector2:
        """Returns an IVector2() generated by rounding this Vector2()"""
        return IVector2(int(round(self.x)), int(round(self.y)))

    def ceiled(self) -> IVector2:
        """Returns an IVector2() generated by ceiling (rounding up) this Vector2()"""
        return IVector2(int(math.ceil(self.x)), int(math.ceil(self.y)))

    def floored(self) -> IVector2:
        """Returns an IVector2() generated by flooring (rounding down) this Vector2()"""
        return IVector2(int(math.floor(self.x)), int(math.floor(self.y)))

    def normalized(self) -> Vector2:
        """Returns a normalized (length == 1) version of this Vector2()"""
        return Vector2(self.x / self.x, self.y / self.y)


@dataclass
class Rect2:
    """A 2D rectangle.

    x: Position on the X axis.
    y: Position on the Y axis.
    w: Size on the X axis (width).
    h: Size on the Y axis (height).
    """

    def __init__(self, x: float, y: float, w: float, h: float) -> None:
        super().__init__()
        self.x: float = x
        self.y: float = y
        self.w: float = w
        self.h: float = h

    @staticmethod
    def from_vectors(topleft: Vector2 | IVector2, size: Vector2 | IVector2) -> Rect2:
        """Creates a Rect2() from two Vector2()s/IVector2()s

        topleft: The Vector2()/IVector2() that provides the X and Y components
        size: The Vector2()/IVector2() that provides the W and H components
        """
        return Rect2(topleft.x, topleft.y, size.x, size.y)

    @staticmethod
    def ZERO() -> Rect2:
        """Equivalent to Rect2(0, 0, 0, 0)"""
        return Rect2(0, 0, 0, 0)

    @staticmethod
    def ONE() -> Rect2:
        """Equivalent to Rect2(0, 0, 0, 0)"""
        return Rect2(0, 0, 0, 0)

    def center(self) -> Vector2:
        """Returns the position of the center of the Rect2() as a Vector2()"""
        return Vector2(self.x + (self.w / 2.0), self.y + (self.h / 2.0))

    def rounded(self) -> IRect2:
        """Returns an IRect2() generated by rounding this Rect2()"""
        return IRect2(
            int(round(self.x)),
            int(round(self.y)),
            int(round(self.w)),
            int(round(self.h)),
        )

    def ceiled(self) -> IRect2:
        """Returns an IRect2() generated by ceiling (rounding up) this Rect2()"""
        return IRect2(
            int(math.ceil(self.x)),
            int(math.ceil(self.y)),
            int(math.ceil(self.w)),
            int(math.ceil(self.h)),
        )

    def floored(self) -> IRect2:
        """Returns an IRect2() generated by ceiling (rounding down) this Rect2()"""
        return IRect2(
            int(math.floor(self.x)),
            int(math.floor(self.y)),
            int(math.floor(self.w)),
            int(math.floor(self.h)),
        )


@dataclass
class IRect2:
    """An integer 2D rectangle."""

    def __init__(self, x: int, y: int, w: int, h: int) -> None:
        super().__init__()
        self.x: int = x
        self.y: int = y
        self.w: int = w
        self.h: int = h

    @staticmethod
    def from_vectors(topleft: IVector2, size: IVector2) -> IRect2:
        """Creates an IRect2() from two IVector2()s

        topleft: The IVector2() that provides the X and Y components
        size: The IVector2() that provides the W and H components
        """
        return IRect2(topleft.x, topleft.y, size.x, size.y)

    @staticmethod
    def ZERO() -> IRect2:
        """Equivalent to IRect2(0, 0, 0, 0)"""
        return IRect2(0, 0, 0, 0)

    @staticmethod
    def ONE() -> IRect2:
        """Equivalent to IRect2(1, 1, 1, 1)"""
        return IRect2(1, 1, 1, 1)

    def center(self) -> IVector2:
        """Returns the position of the center of the IRect2() as a IVector2()"""
        return IVector2(self.x + (self.w // 2), self.y + (self.h // 2))

    def floaty(self) -> Rect2:
        """Returns an IRect2() generated by rounding this Rect2()"""
        return Rect2(self.x, self.y, self.w, self.h)

    def as_sdl_rect(self) -> SDL_Rect:
        """Returns an SDL_Rect structure with the values of this IRect2()"""
        return SDL_Rect(x=self.x, y=self.y, w=self.w, h=self.h)


@dataclass
class RGBAMask:
    """Represents an RGBA color mask/format"""

    def __init__(self, *args, r: int, g: int, b: int, a: int) -> None:
        self.r: int = r
        self.g: int = g
        self.b: int = b
        self.a: int = a

    @staticmethod
    def RGBA() -> RGBAMask:
        """Equivalent to RGBAMask(r=0xFF000000, g=0x00FF0000, b=0x0000FF00, a=0x000000FF)"""
        return RGBAMask(r=0xFF000000, g=0x00FF0000, b=0x0000FF00, a=0x000000FF)

    @staticmethod
    def ARGB() -> RGBAMask:
        """Equivalent to RGBAMask(a=0xFF000000, r=0x00FF0000, g=0x0000FF00, b=0x000000FF)"""
        return RGBAMask(a=0xFF000000, r=0x00FF0000, g=0x0000FF00, b=0x000000FF)

    @staticmethod
    def ABGR() -> RGBAMask:
        """Equivalent to RGBAMask(a=0xFF000000, b=0x00FF0000, g=0x0000FF00, r=0x000000FF)"""
        return RGBAMask(a=0xFF000000, b=0x00FF0000, g=0x0000FF00, r=0x000000FF)

    @staticmethod
    def ZERO() -> RGBAMask:
        """Equivalent to RGBAColor(r=0, g=0, b=0, a=0)"""
        return RGBAMask(r=0, g=0, b=0, a=0)

    def as_int(self) -> int:
        return self.r | self.g | self.b | self.a


@dataclass
class RGBAColor:
    """Represents an RGBA color with variable bit depth
    (when using RGBAColor().as_bytes())
    """

    def __init__(self, *args, r: int, g: int, b: int, a: int) -> None:
        self.r: int = r
        self.g: int = g
        self.b: int = b
        self.a: int = a

    @staticmethod
    def WHITE() -> RGBAColor:
        """Equivalent to RGBAColor(r=255, g=255, b=255, a=255)"""
        return RGBAColor(r=255, g=255, b=255, a=255)

    @staticmethod
    def BLACK() -> RGBAColor:
        """Equivalent to RGBAColor(r=0, g=0, b=0, a=255)"""
        return RGBAColor(r=0, g=0, b=0, a=255)

    @staticmethod
    def TWHITE() -> RGBAColor:
        """Equivalent to RGBAColor(r=255, g=255, b=255, a=0)"""
        return RGBAColor(r=255, g=255, b=255, a=0)

    @staticmethod
    def TBLACK() -> RGBAColor:
        """Equivalent to RGBAColor(r=0, g=0, b=0, a=0)

        Same as RGBAColor.ZERO()
        """
        return RGBAColor(r=0, g=0, b=0, a=0)

    @staticmethod
    def ZERO() -> RGBAColor:
        """Equivalent to RGBAColor(r=0, g=0, b=0, a=0)

        Same as RGBAColor.TBLACK()
        """
        return RGBAColor(r=0, g=0, b=0, a=0)

    # TODO: Add more colors

    def as_int(self, bits_per_channel: int) -> int:
        if bits_per_channel > 8:
            raise ValueError("bits_per_channel must be in range(0, 8) (0-7)")

        return (
            self.a
            | self.b << (bits_per_channel * 1)
            | self.g << (bits_per_channel * 2)
            | self.r << (bits_per_channel * 3)
        )
